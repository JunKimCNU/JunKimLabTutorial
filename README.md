# 김준네 연구실 튜토리얼
## 목록
- [튜토리얼을 시작하시는 걸 환영합니다](#wellcome_to_JunKimLabTutorial)
- [대용량 시퀀싱 데이터에 대한 기본적인 이해](#basis_for_huge_sequencing_data)
- [까만 바탕에 하얀 글씨-리눅스에서 작업 하기](#linux_tutorial)
- [행렬 데이터 다루기](#parsing)
- [Conda를 이용한 프로그램 설치](#conda)
- [기본적인 프로그램 다뤄보기](#basic_programs)
- [시퀀싱 데이터 다루기 101](#how_to_handle_sequencing_data)

## <a name="wellcome_to_JunKimLabTutorial"></a> 튜토리얼을 시작하시는 걸 환영합니다

- 이 자료는 충남대학교 생명시스템과학대학 생명정보융합학과에서 일하고 있는 김준이 만들었습니다.
- 일단은 제 연구실에 관심 있는 학생들에게 컴퓨터를 이용해 어떻게 생명현상을 이해할 수 있는지 가르쳐주기 위해 만든 자료입니다.
- 주로 **롱리드 시퀀싱(long-read sequencing)** 데이터과 이를 활용한 다양한 생물학 연구를 다룹니다.
- 교육용 목적으로는 어떤 식으로 이용해도 좋으니 편하게 가져다 쓰시길 바랍니다.
- 궁금한 점은 위쪽에 보이는 [Issues](https://github.com/JunKimCNU/JunKimLabTutorial/issues)에 남기시면 됩니다.
- 각 실습 자료는 읽는 데 1시간 이내, 실습하는 데 3-4시간 정도를 들이면 충분하도록 짰습니다만, 익숙해지는 정도에 따라 시간 차가 있을 순 있습니다.
- 중요한 건 하다 보면 금방 익숙해질 거라는 점입니다. 사람마다 시간 차가 있을지언정, 충분한 시간만 들이면 누구나 익숙해질 수 있습니다.
- 기본적으로는 코딩하는 법을 다루지 않습니다. 좋은 프로그램이 이미 정말 많이 개발돼 있기 때문에 코딩할 필요가 거의 없기 때문입니다.
- 그렇기 때문에 주로 다루는 일은 이런 프로그램을 갖다 쓰는 방법입니다. 코딩보다는 스크립팅에 가깝습니다.
- 현존하는 다양한 프로그램만 잘 활용할 줄 알아도 수많은 생물학 연구를 해낼 수 있습니다.
- 이 튜토리얼을 다 끝낸 뒤에는 본격적인 연구를 시작할 수 있는 수준일 겁니다. 그렇게 되길 기대합니다.

## <a name="basis_for_huge_sequencing_data"></a> 대용량 시퀀싱 데이터에 대한 기본적인 이해
- 본 튜토리얼에서는 대용량 시퀀싱 데이터에 대해 이해하고, 고성능 컴퓨터를 이용해 이를 처리하는 방식에 대해 배웁니다.
### 시퀀싱이란?
- 그 첫 번째 단계로 시퀀싱 데이터가 무엇인지, 왜 고성능 컴퓨터를 활용해야 하는지 알아보고자 합니다.
- 시퀀싱이란 DNA, RNA, 단백질 등 실처럼 생긴 선형(linear) 분자 안에 담긴 단량체(monomer)의 정보를 읽어내는 과정을 가리킵니다.
- 이들 DNA, RNA, 단백질은 생물학의 중심 원리(central dogma)에 등장하는 가장 핵심 생체 분자입니다. 그러니 이 분자들에 담긴 정보를 읽어내 사람마다 어떤 DNA/RNA/단백질이 다르기에 어떤 사람은 특정한 병에 더 잘 걸리는데 다른 사람은 그렇지 않은지 확인하고 싶은 연구자가 많습니다. 이런 표현형 차이를 만들어내는 유전형 등의 차이를 이해할 수 있다면 진단이나 약물 개발과 치료 등 다양한 시도를 해볼 수 있을 테니까요.
- 우리가 맨눈으로도 이런 선형 분자에 담긴 정보를 읽어낼 수 있다면 좋겠지만, 현실적으로는 불가능합니다. 그러니 우리 눈을 대신할 수 있는 간접적인 방식을 통해 선형 분자 안에 담긴 단량체 정보를 확인하는 일이 필요합니다. 그리고 이렇게 확인한 정보를 우리가 이해할 수 있는 문자 형태의 분자로 바꾸면 좋겠죠. 이 과정이 시퀀싱 과정인 셈입니다. 시퀀싱이란 말 그대로, 기다란 선형 분자 안에 담긴 단량체의 정보를 순서대로 읽어내는 것입니다.

### DNA 시퀀싱
- DNA는 이러한 주요 선형 분자 중에서도 가장 효과적으로 시퀀싱 데이터를 대량 생산할 수 있는 주요 생체 분자입니다. 생체의 DNA는 주로 아데닌, 타이민, 구아닌, 사이토신이라는 4개 분자로 이뤄져 있습니다. 그리고 이 4개의 분자가 각각 양손을 내민 채 옆 분자를 붙들고 있는 게 DNA라는 선형 분자의 생김새입니다.
- 예컨대 사람의 DNA는 약 30억 개의 단량체로 이루어져 있는데요, 이를 30억 **염기쌍**(basepair; bp)이라고 부릅니다. 이들 중 거의 대부분은 23개의 염색체에 담겨있으며, 이러한 염색체는 그 자체로 나름 안정화된 구조를 이룹니다. 참고로 DNA는 2개의 실이 서로 마주 보고 뱀처럼 휘감긴 형태를 띠고 있는데, 이중나선이라는 표현은 여기에서 나온 것입니다.
- DNA를 시퀀싱한다는 것은, 이처럼 사람의 DNA에 있는 단량체 정보를 순서대로 읽어내 우리가 이해할 수 있는 문자로 변환하는 것입니다. 여기서 아데닌은 A, 타이민은 T, 구아닌은 G, 사이토신은 C로 표현합니다. 시퀀싱이 끝난 데이터는 예를 들면 ATGCTAGCTTTAGCCTAGCTACGT 같은 문자열이 됩니다.
- DNA를 시퀀싱할 수 있는 기법은 상당히 많고 지금도 계속해서 개발되고 있습니다만, 본 튜토리얼에서는 이를 크게 둘로 나누고자 합니다. 하나는 숏리드(short-read) 시퀀싱 기법이며, 다른 하나는 롱리드 시퀀싱 기법입니다. 이는 한번에 읽어내는 DNA 분자의 길이에 따라 나누는 구분입니다. 숏리드 시퀀싱이란 대개 300염기쌍 미만의 DNA 단량체 서열을 한번에 읽어내는 기법을 가리키며, 롱리드 시퀀싱이란 보통 대부분의 서열 정보가 10,000염기쌍 이상의 DNA 단량체 서열을 한번에 읽어내는 기법을 가리킵니다. 이렇게 한번에 읽어낸 DNA 서열 정보를 **리드**라고 부릅니다.
- DNA 시퀀싱 실험 과정을 이해함으로써 리드에 대해 조금 더 정확하게 알아봅시다.
- DNA 시퀀싱 과정은 실험마다 차이가 있긴 합니다만, 보통은 DNA를 자르는 데에서 시작합니다. DNA를 자르는 이유는 단순합니다. 한없이 긴 DNA라면, 그 안에 담긴 단량체 정보를 처음부터 끝까지 한번에 읽어낼 수 있는 기술이 없는 것이나 다름 없기 때문입니다(있긴 합니다). 그렇기 때문에 DNA를 시퀀싱하는 경우에는 대부분 DNA를 잘라서 읽기 편한 길이로 맞춰줍니다. 숏리드 시퀀싱 기법이라면 500염기쌍에서 700염기쌍 정도로, 롱리드 시퀀싱 기법이라면 20,000염기쌍이나 그보다 긴 길이 정도로 맞춰줍니다. 그리고 이 조각난 DNA에 담긴 단량체 정보를 A, T, G, C 등으로 바꿔주는 것입니다. 다시 한 번 강조하자면, 이렇게 한번에 읽은 DNA 조각을 리드라고 부릅니다.
- 리드가 길면 하나의 분자에서 훨씬 더 많은 정보를 얻을 수 있으며, 그로 인해 리드가 짧을 때는 분석할 수 없는 생명현상을 들여다볼 수 있게 됩니다. 이는 뒷부분에서 기술할 예정입니다.
- 보통 이런 DNA 조각, 즉 리드를 한두 개만 읽진 않습니다. 사람의 유전체 정보를 분석한다고 하면 전체를 적어도 한 번은 읽어야 할 테니 30억 염기쌍은 읽어야겠죠. 대충 150염기쌍을 읽어내는 숏리드 시퀀싱 기법으로는 이런 리드를 적어도 2천만 개를 읽어야 합니다. 대충 15,000염기쌍을 읽어내는 롱리드 시퀀싱 기법이라면 20만 개면 거뜬하죠. 물론 실제로는 이러한 숫자의 30배 정도를 생산하긴 합니다.

### DNA 시퀀싱 데이터 양식
- DNA에 담긴 정보는 여러 형태로 저장될 수 있습니다만, 가장 표준화된 데이터 양식(format)은 크게 두 가지가 있습니다. 하나는 **FASTA**, 다른 하나는 **FASTQ**입니다. 파스타와 파스트큐, 패스트에이와 패스트큐 등등 다양하게 불립니다. 대충 아무렇게나 불러도 다 알아듣는다는 뜻입니다.
- 참고로 DNA에만 쓰이는 양식은 아니며, 선형 분자라면 어떤 것이든 표현할 수 있습니다.
- FASTA 포맷은 DNA 분자의 **이름**과 단량체 **서열** 정보를 담고 있습니다. 예를 들면 다음과 같은 형태를 띱니다.
```
>read_00001
ATGCTACGTACGTACGTAGCTACGATCGATCGATCGTAGTACACAATTTCGCGCCGCTCG
AAATCTCGGGCTCCCATCACGTACGAGCTAGCTAGCTAGCTACGATCGATCGATCGATGT
```
- FASTA 포맷에서 DNA 분자의 이름은 ```>```로 시작합니다. 여기서는 ```read_00001```이라는 것이 해당 DNA의 이름이 됩니다. 그리고 ```ATGCT......GATGT```에 해당하는 부분이 이 read_00001이라는 DNA 분자에 담겨있던 단량체의 서열 정보가 됩니다.
- FASTA는 한 파일에 여러 개의 DNA 서열 정보가 담기기도 합니다. 다음과 같이 여러 줄로 DNA 정보가 표현되는 것이죠.
```
>read_00001
ATGCTACGTACGTACGTAGCTACGATCGATCGATCGTAGTACACAATTTCGCGCCGCTCG
AAATCTCGGGCTCCCATCACGTACGAGCTAGCTAGCTAGCTACGATCGATCGATCGATGT
>read_00002
ATGATAAATCGTACGATTTTTTTCCCCCCCGATGCTAGTCGATCGAAAACGTACGTAGCT
TAGCTAGCTTTACACACGGGGAAAGTGCAAAGTCGTACGGGCACATGTCGGACTAGCTAG
GTAGCTAGCTAACAGTCGCTGGCATGCATCATTGCTAGCTAGCCGCTAGCTAGTCGATTT
```
- 이때 한 DNA의 정보가 시작되고 끝나는 위치는 DNA의 이름을 알려주는 ```>``` 문자를 통해 확인할 수 있습니다. 위 예제에서처럼 한 DNA 분자는 120염기쌍 정보를 담고 있고, 다른 DNA 분자는 180염기쌍을 담고 있으면 길이가 달라서 어디서부터 어디까지가 이름인지 알기 어렵겠죠? 그렇기 때문에 길이가 아닌 ```>``` 문자가 시작하면 새로운 DNA 분자에 대한 정보가 나온다는 약속을 해둔 것입니다. DNA 길이는 엄청나게 길어질 수도 있습니다. 다음 ```>``` 문자가 나오기 전까지는 아무리 길어도 하나의 DNA 정보라고 생각하면 됩니다.
- FASTQ는 FASTA와 정말 비슷하지만, 중요한 차이점을 몇 가지 지니고 있습니다. FASTA는 DNA의 이름과 서열 정보만 담고 있지만, FASTQ는 이름과 서열 외에도 부가적인 **옵션** 정보와 각 염기의 정확도를 알려주는 **퀄리티(quality)** 정보가 함께 담겨 있다는 것이 가장 중요한 차이점입니다. 예를 들면 다음과 같은 형태를 띠고 있습니다.
```
@read_00001
ATGCTACGTACGTACGTAGCTACGATCGATCGATCGTAGTACACAATTTCGCGCCGCTCG
AAATCTCGGGCTCCCATCACGTACGAGCTAGCTAGCTAGCTACGATCGATCGATCGATGT
+
DBD0@GHIIHHHHIGEHFH@G1@GCGHHFHIE1GHIIIHIIHHHHHIIG@GFCF@D@DHC
HHHHIEHI1@@CGHI@GH1G1D0@CC@CE@CCFH@1@CEHHHHFCHHHCHHIHEHHEHEH
```
- FASTQ에서 DNA의 이름은 **@** 문자 다음에 나옵니다. 그 다음 줄부터 **서열** 정보가 시작되며, **+** 기호가 나오면 DNA 서열 정보가 끝났다는 뜻이 됩니다. 그리고 마지막 줄에 **퀄리티** 정보가 담기게 되죠. 마찬가지로 이 품질 정보는 다음 **@** 기호가 나오면 끝나게 됩니다.
- 현존하는 시퀀싱 기법은 대부분 오류를 만들어낼 가능성이 있기 때문에 이러한 퀄리티 정보가 포함된 FASTQ 양식이 널리 쓰이고 있습니다.
- 여기서 퀄리티 정보의 길이는 DNA의 서열 정보와 같은데요, 이는 퀄리티 줄의 각 문자 하나가 짝지어진 DNA 서열의 정확도를 가리키기 때문입니다.
- 예를 들면 첫 번째 DNA 서열 정보인 A, 그 다음의 T, 그 다음의 G는 각각 "D", "B", "D"라는 퀄리티를 지니고 있다는 뜻이 됩니다.
- 이 퀄리티는 기본적으로는 ```-10×log(Error rate)```입니다.
- 예를 들면 시퀀싱 결과 첫 번째 단량체가 A라고 판정했는데, 실험적 오류로 인해 10% 정도는 T일 것 같다고 쳐봅시다. 그러면 이때 퀄리티 값은 ```-10×log(0.1) = 10``` 이 되겠죠.
- 그런데 이렇게 십진법으로 나타내면 퀄리티 값이 2개의 문자로 표현하게 될 가능성이 매우 높다는 문제가 생깁니다. 서열 정보와 짝 지어질 수 없게 되는 게 문제입니다. 예를 들면 ATGC라는 서열 1021121이라는 퀄리티 정보를 지닌다고 했을 때, 각 단량체 정보의 정확도가 10, 21, 12, 1인지, 아니면 10, 2, 11, 21인지 등등 알기가 어렵겠죠. 서열 문자와 퀄리티 정보가 모두 1개의 문자로 표현되는 게 필요한 겁니다.
- 이런 문제를 해결하기 위해 퀄리티 값을 1개의 문자만으로 표현할 수 있도록 하는 [장치](https://support.illumina.com/help/BaseSpace_OLH_009008/Content/Source/Informatics/BS/QualityScoreEncoding_swBS.htm)가 쓰이고 있습니다. 십진법으로는 두 자리인 숫자도 모두 1개의 문자로 표현할 수 있는 방식이죠.
- 예컨대 ```read_00001```의 첫 3개 정보인 A, T, G는 각각 D, B, D라는 퀄리티 값을 지니고 있는데요, 이는 각각 35, 33, 35를 가리킵니다. 오류일 가능성은 각각 10<sup>-3.5</sup>, 10<sup>-3.3</sup>, 10<sup>-3.5</sup>인 셈이니 상당히 믿을만한 정확도라고 볼 수 있겠죠.

### 시퀀싱 플랫폼별 차이점
- 현재 가장 널리 쓰이는 숏리드 시퀀싱 기법은 Illumina, BGI 등이 제공하고 있으며, 가장 널리 쓰이는 롱리드 시퀀싱 기법은 PacBio와 ONT 등이 제공하고 있습니다.
- 숏리드 시퀀싱은 리드 길이가 짧은 대신 정확도가 높고 값이 매우 저렴하다는 장점을 지닙니다. 인간 유전체의 30배(30×라고도 부름) 정도를 생산한다고 치면 900억 염기쌍, 다른 말로는 90 Gb (90×10<sup>9</sup>염기쌍)를 얻는 수준인데요, 한국 돈으로 대략 100만 원 정도 소요됩니다(업체 기준).
- 롱리드 시퀀싱은 업체별로 기술의 장점이 다릅니다만, 둘 다 비싸다는 단점은 똑같습니다.
- PacBio만이 제공하고 있는 롱리드 시퀀싱 기법은 HiFi 시퀀싱 기법이라고 불립니다. 이는 다음과 같은 특징을 지닙니다.
- HiFI 시퀀싱 기법은 정확도가 매우 높은 롱리드 시퀀싱 기법입니다. 2023년 현재 기준으로는 숏리드 시퀀싱 기법의 정확도를 뛰어넘어 Q40 (퀄리티 40, 즉 오류 가능성 10<sup>-4</sup> 수준)을 넘는 리드를 제공해줍니다. DNA 시퀀싱의 표준이 되고 있습니다.
- HiFi 시퀀싱 기법의 리드 길이는 약 20,000염기쌍, 즉 20 kb 수준입니다. 이는 시퀀싱 화학 반응의 특징 때문인데, HiFi 시퀀싱 기법은 하나의 DNA 이중나선을 원형(circular)으로 만든 뒤 여러 차례 읽어 오류를 줄입니다. 이처럼 원형을 만든 뒤 여러 번 읽어내려면 DNA 길이가 현재로서는 20 kb 수준이어야 가장 적당합니다.
- HiFi 시퀀싱 기법은 DNA 메틸화(methylation) 등을 확인할 수 있게 해줍니다.
- HiFi 시퀀싱 기법을 이용해 30× 인간 유전체 데이터를 생산한다면, 현재 한국 돈으로 대략 500만 원 정도 소요됩니다.
- ONT에서 제공하는 시퀀싱 기법은 나노포어 단백질을 활용합니다. DNA나 RNA 같은 선형 분자가 이 나노포어 단백질을 지날 때 나타나는 전류 차이를 이용해 단량체 서열 정보를 확보할 수 있습니다.
- ONT에서 제공하는 가장 두드러진 시퀀싱 데이터 유형은 울트라 롱리드(ultra-long-read) 시퀀싱 데이터입니다. 이는 상당수의 DNA 정보가 200 kb 수준이고 가장 긴 DNA 분자는 Mb 수준으로 읽힌다는 강점을 지니고 있습니다. 유전체 지도 작성시 보조 데이터로 많이 활용됩니다.
- ONT 울트라 롱리드 시퀀싱 데이터는 생산해주는 업체가 많지 않지만, 30× 인간 유전체 데이터 기준 대략 800만 원 정도 듭니다.
- ONT는 현존하는 시퀀싱 기법 중 유일하게 DNA는 물론 RNA에 있는 변형(modification)까지도 확인할 수 있다는 강점을 지닙니다. 관련해서는 다양한 실험 기법과 분석 프로그램이 계속해서 개발되고 있습니다.
- ONT의 정확도는 그렇게 높지는 않으며, 대략 Q20 내외라고 생각합니다.
- 이외에도 Dovetail이나 Arima Genomics 사의 HiC 시퀀싱 기법(physical mapping/chromatin interaction 등 관찰 가능), Bionano 사의 옵티컬 매핑(optical mapping) 기법 등도 널리 쓰입니다.
- 이러한 시퀀싱 데이터는 대부분 컴퓨터에 저장된 채로 활용됩니다. 거의 대부분은 고성능(high-performance) 컴퓨터를 이용해 시퀀싱 데이터를 처리하게 됩니다.

### 왜 고성능 컴퓨터를 활용하나?
- 시퀀싱 데이터를 활용하려면 고성능 컴퓨터가 거의 필수적입니다. 데이터 자체가 엄청난 양으로 생산되다 보니, 이러한 대용량 데이터를 다루려면 일반 컴퓨터로는 매우 오랜 시간이 걸리기 때문입니다. 데이터를 빠르게 처리해서 좋은 논문으로 낸 뒤 졸업하려면 고성능 컴퓨터를 다룰 수 있어야만 합니다.
- 고성능 컴퓨터의 운영체제에는 대개 리눅스(Linux) 기반 운영체제가 쓰입니다. 참고로 윈도우즈 같은 게 운영체제입니다.
- 예컨대 제가 처음으로 썼던 서버는 우분투 16.04라는 운영체제가 설치돼 있었습니다. 여기서 "우분투"는 "윈도우즈"와 대응하는 개념이며, "우분투 16.04"는 "윈도우즈 10"과 비슷한 개념입니다. 리눅스 기반 운영체제인 우분투의 16.04 버전을 썼다는 뜻입니다.
- 이러한 리눅스 기반 서버에 익숙해지는 것이 다음 단계의 목표입니다.
- 정확하게는 커맨드라인 인터페이스(command-line interface; CLI라고도 부름)에 익숙해지는 과정이 필요합니다. 이는 많은 사람들이 익숙한 그래픽 사용자 인터페이스(graphical user interface; GUI)와 대응하는 개념입니다.
- GUI는 쉽게 말하면 화면에 보이는 아이콘 등을 마우스로 클릭하는 것을 가리킵니다.
- CLI는 화면에 아이콘 같은 그림은 아예 없고 문자만 나오는 것을 가리키며, 키보드만 가지고 모든 작업을 할 수 있도록 설계돼 있습니다.
- 대부분의 서버를 활용하려면 이러한 커맨드라인에 익숙해지는 과정이 필요합니다. 리눅스 운영체제도 GUI를 활용하는 경우가 매우 많습니다만, 일반적인 서버는 대개 커맨드라인을 기반으로 운용됩니다. 그러니 이 커맨드라인에 익숙해지는 연습을 꾸준히 반복해서 컴퓨터와 친해지도록 합시다.

## <a name="linux_tutorial"></a> 까만 바탕에 하얀 글씨-리눅스에서 작업 하기
### 리눅스 터미널 열기
- 리눅스 운영체제에서 작업하는 법을 익히려면, 리눅스 운영체제가 깔린 컴퓨터가 있어야 합니다.
- 제 수업 듣는 학생이나 연구실 사람이라면 제가 운영하고 있는 서버에 접속하시면 됩니다. 그전에 먼저 서버 접속에 필요한 프로그램을 설치해야 합니다. 맥을 쓰신다면 터미널 열고 접속하시면 되겠습니다만, 윈도우즈를 쓰신다면 [MobaXterm](https://mobaxterm.mobatek.net/download.html)을 설치하시길 추천 드립니다. Home Edition 클릭한 뒤 Portable edition 클릭해서 다운 받고 실행하시면 되겠습니다. 이후 접속에 필요한 정보를 입력하시면 됩니다.
- 다른 분들은 본인 운영체제에 맞춰 다음과 같이 진행하시면 됩니다.
- 맥 계열 운영체제를 쓰고 있다면 바로 터미널을 열고 작업을 시작하면 됩니다.
- 윈도우즈 계열 운영체제를 쓰고 있다면 [WSL](https://learn.microsoft.com/ko-kr/windows/wsl/install)을 이용해 리눅스를 사용할 수 있습니다. 다만 윈도우즈 10 또는 윈도우즈 11이어야 활용 가능합니다. 설치는 간단하게 진행할 수 있는데요, Power Shell을 관리자 권한으로 실행한 뒤, ```wsl --install```을 입력합니다. 그 뒤 Microsoft Store에 들어가서 Ubuntu 다운로드하고 컴퓨터 재시작하면 설치 완료입니다. 그 뒤 윈도우즈키 누르고 "Ubuntu" 검색하시면 됩니다.
- 이제 검은 배경화면에 하얀 글씨가 뜬 **터미널**이 열렸을 겁니다. 다음과 같은 줄이 보이면 성공입니다.
```console
어쩌구@저쩌구:~$
```
- 이제 본격적인 학습을 시작해봅시다.

### 터미널에서 작업하기 위한 기본 명령어
- 시작하기에 앞서 한 가지 유의할 점을 미리 알려드리겠습니다. 여기에 나와있는 명령어들은 마이크로소프트 워드 같은 데 저장하시면 매우 높은 확률로 명령어가 이상해질 가능성이 높습니다. 워드에 내장된 자동 변환 기능이 특정한 문자를 다른 문자로 바꿔버리기 때문에 나타나는 현상인데요, 대표적인 예로 ```'```는 ```‘``` 및 ```’```와는 **완전히 다른 문자**로 인식됩니다. 마찬가지로 ```"``` 또한 ```“``` 및 ```”```와는 완전히 다른 문자입니다. 반드시 주의하시기 바랍니다. 메모장 같이 자동 변환 기능이 없는 텍스트 에디터를 활용하시길 추천 드립니다.
- 터미널에서 작업한다 해도, 컴퓨터를 사용하는 기본적인 방식은 아이콘 클릭하는 것과 다를 게 없습니다. 마우스로 클릭하는 대신 키보드를 활용해 다양한 명령어(command)를 입력하는 게 다를 뿐이죠. 여전히 우리는 특정한 디렉토리(폴더)에서 작업하게 되며, 디렉토리와 디렉토리를 이동하며 다양한 파일들을 읽고 쓰게 실행하게 될 겁니다. 키보드로 입력하는 다양한 명령어를 활용해서 말이죠.
- 가장 기본적인 명령어를 입력해봅시다. 그래픽 기반으로 작동하는 경우에는 디렉토리를 더블클릭해서 들어가면 자동으로 현재 디렉토리 안에 있는 다양한 파일과 하부 디렉토리 등을 보여줄 겁니다. 그렇지만 지금 터미널에는 아무것도 나와있지 않고 본인 아이디와 위치 정도만 나와있을 겁니다.
```console
어쩌구@저쩌구:~$
```
- 현재 디렉토리에 들어있는 파일이 무엇인지 확인하고 싶다면 ```ls```를 적고 엔터를 쳐봅시다. ```ls```란 list의 약자로, 현재 디렉토리 안에 있는 내용물의 목록을 뽑아주는 명령어입니다.
```console
어쩌구@저쩌구:~$ ls
directory1 directory2
어쩌구@저쩌구:~$
```
- 현재 디렉토리 안에 뭐라도 들어있다면 위에 보이는 것처럼, ```ls``` 이후 엔터를 쳤을 때 그 내용물이 뭔지를 보여줄 겁니다. 그래픽 기반처럼 자동으로 내용물을 보여주진 않지만, 아주 간단하게 내용물을 볼 수 있는 셈이죠. 참고로 제 서버에서는 기본적으로 ```l```만 쳐도 ```ls```를 친 것과 거의 동일한 결과를 보여줍니다.
(QUIZ) ```ls```는 파일 이름만 보여주지만, ```ls -l```을 치면 디렉토리 안에 있는 내용물들의 다른 정보들도 제공해줍니다. 직접 한번 이 명령어를 쳐보고 각 줄이 어떤 걸 뜻하는지 검색해서 이해해봅시다. 참고로 제 서버에서 ```ll```만 쳐도 ```ls -l```을 친 것과 거의 동일한 결과를 확인할 수 있습니다.
### 집중해주세요!
- 참고로, 거의 모든 명령어는 ```명령어 --help``` 또는 ```명령어 -h```를 치면 설명서가 나오게 설정돼 있습니다. 이해가 잘 안 된다면 검색창에 검색해서 사용법을 익히도록 합시다.

- 다음으로 가장 간단한 텍스트 에디터를 사용해봅시다. 터미널에 ```nano test```라고 쳐봅시다.
- 참고로 ```nano```와 ```test```는 반드시 그 사이에 **빈칸**이 하나 들어가야 합니다. 빈칸이 들어가야 ```nano```가 명령어로 인식되고, 뒤의 ```test```는 이 ```nano```를 사용해 열고자 하는 파일 이름이라는 것이 인식됩니다. 이후에 쓰는 다양한 명령어들도 모두 마찬가지입니다. 중요하니 꼭 주의해주세요.
```console
어쩌구@저쩌구:~$ nano test
```
- 그러면 빈 파일이 하나 열리게 될 겁니다. 가운데 위쪽을 보면 "test"라는 글자가 보일 텐데, 이게 파일 이름을 가리킵니다. 이 상태에서 원한다면 아무 문자나 입력하시면 됩니다. 그러면 메모장에 글을 쓰듯 test라는 파일에 내용이 채워지죠. 이 파일에 ```Hello world```라는 문자열을 입력해봅시다.
- 이 상태에서 나가고 싶다면 아래쪽에 쭉 적혀 있는 내용들을 읽으시면 되는데요, 자세히 보시면 ```^X Exit```라고 적힌 게 보일 겁니다. 여기서 ```^``` 문자는 키보드의 컨트롤 키를 가리킵니다. 여기 적힌 것처럼 파일을 수정 중인 메모장에서 나가고(exit) 싶다면 ```ctrl+x```를 치시면 됩니다. 키보드 왼쪽 아래 컨트롤 키와 x 키를 누르면 나가지게 될 겁니다.
- 다만 우리처럼 뭐라도 내용을 채웠다면 저장할 건지 등을 물어봅니다. ```Save modified buffer?```라는 말이 보일 텐데요, 이때 왼쪽 아래에 있던 명령어들이 ```Yes```, ```No```, ```Cancel``` 등으로 바뀌어있는 걸 보실 수 있을 겁니다. 우리는 저장해야 하니, ```Yes``` 앞에 적힌 대로 Y를 누릅시다. 그러고 나면 ```File Name to write```라는 창으로 바뀌게 될 겁니다. 다른 이름으로 저장하고 싶다면 이름을 수정하면 됩니다. 바꾸지 않고 그냥 엔터를 치면 ```test```라는 파일에 해당 내용이 저장될 겁니다.
- 여기서 하나 중요한 게 있는데요, 리눅스 운영체제에서는 기본적으로 대부분의 파일 확장자가 중요한 역할을 하지 않습니다. ```test.txt```처럼 이 파일이 텍스트 파일이라는 걸 지정해주지 않더라도 상관이 없다는 뜻입니다. ```test```라는 이름만으로도 파일은 텍스트 파일 역할을 하게 됩니다.
- 그리고 생각보다 이런 텍스트 에디터에서 다시 터미널로 나가지 못해 갇힌 사람들이 많습니다. 혹시 나중에 나가는 방법을 까먹었다면 인터넷 검색창에 "how to exit nano" 등을 검색하시면 됩니다. 실제로 다른 텍스트 에디터 중 하나인 Vim도 탈출하기가 쉽지 않다 보니, [How do I exit Vim?](https://stackoverflow.com/questions/11828270/how-do-i-exit-vim)과 같은 질문은 해당 사이트에서 5천 개 이상의 추천을 받았을 정도입니다.
- 중요한 건 잘 검색하면 뭐든 다 나온다는 겁니다. 여러분은 이 세계에 처음 발을 들인 사람도 아니고, 여러분보다 먼저 당하고 헤맨 사람은 세상에 정말 많습니다.
- ```nano```라는 텍스트 에디터 말고 다른 명령어를 활용해 파일 내용을 확인하는 법도 배워봅시다. 두 번째로 써볼 명령어는 ```less```입니다. 터미널에 다음과 같이 입력해봅시다.
```console
어쩌구@저쩌구:~$ less test
```
- 이번에는 파일 내용이 화면에 보이게 될 겁니다. 제대로 입력했다면 ```Hello world```라는 말이 적혀있겠죠. 마찬가지로 나가봅시다. ```less```에서 나가려면 ```q```를 치시면 됩니다. 키보드 왼쪽 위에 있는 "Q" 키입니다.
- ```nano```와 ```less```는 용도가 다릅니다. ```nano```는 텍스트 에디터, 즉 파일 내용을 바꾸고 싶을 때 주로 활용할 수 있습니다. 보통 큰 문제 없이 쓸 수 있습니다만, **파일 크기가 크면 바로 랙 걸린다는 문제**를 지니고 있습니다. 파일 크기가 1 Mb를 넘어간다면 ```nano```를 쓰는 순간 바로 랙 걸려서 모든 작업이 멈추게 됩니다. 유의하시면 좋습니다.
- 반면 ```less```는 파일 크기가 커도 문제 없이 잘 작동한다는 강력한 장점을 지니고 있습니다. 대신 파일 내용을 수정하기에는 적합하지 않습니다. 읽기 전용이라고 생각하고 쓰셔도 무방합니다.
- 마지막으로 써볼 명령어는 ```cat```입니다. ```cat```은 "concatenate"의 약자로, 파일의 내용을 연달아 보여주는 명령어입니다. 1개의 파일에 대해서도 쓸 수 있으며, 여러 개의 파일에 대해서도 사용할 수 있습니다. 마찬가지로 터미널에 다음 명령어를 입력해봅시다.
```console
어쩌구@저쩌구:~$ cat test
```
- 그러면 이전에 ```nano```나 ```less```를 썼을 때와는 달리 파일 내용이 화면에 바로 출력되는 걸 확인할 수 있을 겁니다.
```console
어쩌구@저쩌구:~$ cat test
Hello world
어쩌구@저쩌구:~$
```
- 이처럼 ```cat```은 파일의 내용을 수정하거나 한 페이지씩 차근차근 보여주는 것이 아니라, 화면에 고스란히 출력한다는 특징을 지니고 있습니다.
- 참고로 이렇게 화면에 출력된 결과를 ```STDOUT```, 표준 출력이라고 부릅니다. 이건 꽤 중요한 개념이니 기억해두시면 좋겠습니다.
- 다음으로 파일 내용이 아니라, 우리가 원하는 문자를 곧바로 표준 출력해주는 명령어인 ```echo```를 사용해봅시다. 다음 명령어를 쳐보시기 바랍니다.
```console
어쩌구@저쩌구:~$ echo "Hello world"
```
- 그러면 이전에 ```cat test```를 입력했을 때와 마찬가지로 화면에 ```Hello world```라는 문자열이 고스란히 표준 출력으로 나오게 됐을 겁니다.
- 이번에는 이렇게 나온 표준 출력을 새로운 파일에 저장해보도록 하겠습니다. 다음과 같이 명령어를 입력해봅시다.
```console
어쩌구@저쩌구:~$ echo "Hello world!" > test2
```
- 이전과 달리, 이번에는 화면에 ```Hello world!```라는 문자열이 출력되지 않았을 겁니다. 그 이유는 우리가 ```>```라는 연산자를 활용했기 때문입니다. 이 ```>```는 **리디렉션**(redirection)이라고 부릅니다.
- 리디렉션을 활용하면, 표준 출력되어야 할 ```Hello world!```라는 문자열이 ```test2```라는 새로운 파일에 저장되게 됩니다. 다시 말하자면, 출력되어야 할 값이 표준 입력으로 변환돼 파일에 저장되는 것입니다.
- 리디렉션이 어떻게 작동했는지 확인해보고 싶다면 다음 명령어를 입력해봅시다.
```console
어쩌구@저쩌구:~$ cat test2
```
- 이렇게 하면 ```test2```라는 파일에 담긴 내용물이 화면에 출력되겠죠? 제대로 작동했다면, 그 내용인 ```Hello world!```가 화면에 나올 겁니다. 리디렉션을 활용해 화면에 출력될 내용을 ```test2```라는 파일에 저장해뒀기 때문에 일어난 일입니다.
- 마지막으로 ```cat```을 활용해 두 파일의 내용을 동시에, 연달아 확인해봅시다. 다음 명령어를 차례대로 쳐보시기 바랍니다.
```console
어쩌구@저쩌구:~$ cat test test2
어쩌구@저쩌구:~$ cat test2 test
```
- 그러면 두 파일의 내용이 한번에 화면에 출력될 겁니다.
(QUIZ) 위 명령어와 아래 명령어는 다른 결과를 보일 겁니다. 이유는 한번 생각해보시기 바랍니다.
- 파일을 만드는 법을 배워봤으니, 이번에는 디렉토리를 만드는 법을 배워봅시다. 윈도우즈에서 "새로 만들기 - 폴더"를 실행하는 것과 동일합니다. 여기서는 마우스 대신, 키보드를 활용한다는 것만 다르죠. ```mkdir```을 사용해봅시다. ```mkdir```은 "make directory"라는 뜻입니다. 다음 명령어를 입력해주세요.
```console
어쩌구@저쩌구:~$ mkdir sampleDirectory
```
- 엔터 치면 아무 변화도 일어나지 않는 것처럼 보일 겁니다. 하지만 실제로는 무언가 변화가 일어났습니다. 그 차이를 확인하고 싶다면 현재 디렉토리에 들어있는 내용물을 확인해보면 되겠죠? ```ls```를 쳐봅시다.
```console
어쩌구@저쩌구:~$ ls
directory1 directory2 test test2 sampleDirectory
```
- 그러면 이전과 달리, 우리가 새로 만든 파일인 ```test```, ```test2```와 함께 ```sampleDirectory```라는 디렉토리가 새롭게 형성돼있는 것을 확인할 수 있을 겁니다.
- 이제 새로 만든 이 디렉토리로 이동해봅시다. 이동에 쓰이는 명령어는 ```cd```로, "change directory"라는 뜻입니다. 다음 명령어를 입력해주세요.
```console
어쩌구@저쩌구:~$ cd sampleDirectory
```
(QUIZ) 참고로 ```cd s```까지만 치고 키보드에 있는 ```Tab``` 키를 눌러보시면 좋습니다. 이름을 다 적지 않은 상태에서 ```Tab```을 치면 어떤 일이 벌어지는지는 직접 확인해보세요. 또 ```ls t```까지만 친 다음에도 ```Tab```을 쳐보시길 바랍니다. 이때는 ```Tab```을 한번만 치는 게 아니라 두세 번 정도 쳐보시면 좋습니다. 어떤 차이가 있는지 한번 생각해보시고, 인터넷에 검색해서 확인해봅시다.
- 위에서처럼 이동하고 나면, 터미널이 뭔가 바뀌어있는 걸 확인할 수 있을 겁니다.
```console
어쩌구@저쩌구:~$ cd sampleDirectory
어쩌구@저쩌구:~/sampleDirectory$
```
- 명령어를 입력하던 부분이 ```~$```에서 ```~/sampleDirectory$```로 바뀌어있을 겁니다. 디렉토리를 이동했으니, 지금 어디에 있는지 그 위치를 표시해주는 것입니다.
- 다시 원래 있던 디렉토리로 이동해봅시다. 다음 명령어를 입력하시면 됩니다.
```console
어쩌구@저쩌구:~/sampleDirectory$ cd ..
```
- 마찬가지로 ```cd```는 디렉토리를 이동하라는 명령어이며, ```..```은 **상위 디렉토리**라는 뜻입니다. 다시 말해 ```cd ..```이란, ```sampleDirectory```라는 **하위 디렉토리**에 들어오기 전에 작업하고 있던 곳으로 돌아가라는 뜻이 되죠.
```console
어쩌구@저쩌구:~/sampleDirectory$ cd ..
어쩌구@저쩌구:~$
```
- 그러면 위에 보이듯 이전 디렉토리인 ```~```로 돌아오게 될 겁니다.
- 그러면 ```sampleDirectory```에 들어오기 전까지 작업하고 있던 곳, ```~```, 이 물결 표시는 대체 어느 위치였던 걸까요? 이런 걸 확인하고 싶다면, ```pwd``` 명령어를 활용하시면 됩니다. 이는 "print working directory"를 뜻하는 명령어로, 현재 디렉토리의 위치 정보를 보여줍니다.
```console
어쩌구@저쩌구:~$ pwd
/home/어쩌구
```
- 이렇게 pwd를 치면, 화면에 현재 위치 정보가 출력될 겁니다. 보통은 ```/home/본인ID```라고 나올 겁니다. ```~```란 ```/home/본인ID/```를 줄여둔 표현이었던 것입니다.
- 이제 이러한 위치 개념을 조금 더 깊게 배워보겠습니다. 바로 상대 경로(relative path)와 절대 경로(absolute path)라는 개념입니다.
- 상대 경로는 **내가 현재 작업하고 있는 위치가 기준**이 됩니다. 현 위치로부터 하위 디렉토리를 검색하거나, 상위 디렉토리로 이동하는 식으로 작동하죠. 예를 들면 이전까지 했던 ```cd sampleDirectory```와 ```cd ..``` 같은 명령어는 모두 상대 경로를 기반으로 작동하는 것입니다.
- 상대 경로가 작동하는 방식을 알아보고 싶다면 이게 제대로 작동하지 않는 경우를 보면 좋겠죠. 홈 디렉토리에서 다시 한 번 상위 디렉토리로 이동해봅시다.
```console
어쩌구@저쩌구:~$ cd ..
어쩌구@저쩌구:/home$
```
- 그 뒤 우리가 만들었던 ```sampleDirectory```로 이동해봅시다.
```console
어쩌구@저쩌구:/home$ cd sampleDirectory
-bash: cd: sampleDirectory: No such file or directory
```
- 그러면 위에 보이듯, 그런 파일이나 디렉토리가 없다는 문구가 출력될 겁니다. 왜냐면 이 ```sampleDirectory```는 **현재 디렉토리에서는 검색할 수 없는 곳**에 있기 때문입니다. 현재 디렉토리에 있는 내용물을 다시 한 번 확인해봅시다.
```console
어쩌구@저쩌구:/home$ ls
어쩌구
```
- 그러면 위와 같이 본인 아이디가 나올 겁니다. 현재 디렉토리에서는 ```sampleDirectory```가 검색되지 않습니다. ```sampleDirectory```는 ```/home/어쩌구``` 디렉토리의 하위 디렉토리이지, ```/home``` 디렉토리에서 바로 검색 가능한 하위 디렉토리는 아니기 때문입니다.
- 이처럼 상대 경로를 이용하려면, 현재 위치에서 내가 이동하려는 위치 또는 사용하려는 파일이 있는 위치를 정확하게 지시해줘야 합니다. 현재 상황에서 ```sampleDirectory```로 곧장 이동하고 싶다면, 내 홈 위치를 거쳐서 가야만 하는 겁니다. 예를 들면 1번, 2번, 3번 방이 순서대로 있다고 쳤을 때, 1번 방에서 3번 방으로 이동하려면 2번 방을 반드시 거쳐야 하는 것처럼 말이죠.
- 구체적으로는 다음과 같이 이동하면 됩니다.
```console
어쩌구@저쩌구:/home$ cd 어쩌구/sampleDirectory
어쩌구@저쩌구:~/sampleDirectory$
```
- 여기서 ```어쩌구``` 대신에 ```ls```를 쳤을 때 나온 본인 디렉토리 이름을 넣어주시면, 위에 보이듯 한번에 이동하게 될 겁니다. 이번에는 내가 이동하려던 ```sampleDirectory```가 현재 디렉토리에서 바로 접근하는 것이 아닌, ```어쩌구```라는 디렉토리를 거친 뒤에 갈 수 있는 곳이라고 컴퓨터에 알려줬기 때문입니다. 이때 디렉토리 이름과 디렉토리 이름 사이에는 반드시 ```/```가 들어가야 합니다. 그래야 컴퓨터가 ```어쩌구sampleDirectory```라는 이름을 가진 바로 하위에 있는 디렉토리를 검색하지 않고, ```어쩌구```라는 하위 디렉토리 안에 있는 ```sampleDirectory```를 찾아서 들어가줍니다.
- 마찬가지로, 상위 폴더의 상위 폴더로 이동하고 싶을 때도 여러 방식을 쓸 수 있습니다.
```console
어쩌구@저쩌구:~/sampleDirectory$ cd ..
어쩌구@저쩌구:~$ cd ..
어쩌구@저쩌구:/home$
```
- 또는, 한번에 이동할 수도 있죠.
```console
어쩌구@저쩌구:/home$ cd 어쩌구/sampleDirectory   # 안쪽 디렉토리로 이동한 뒤,
어쩌구@저쩌구:~/sampleDirectory$ cd ../..       # 상위 디렉토리의 상위 디렉토리로 한번에 이동
어쩌구@저쩌구:/home$
```
- 이런 상대경로 방식을 활용해서, 내가 작업하고 있는 디렉토리에서 자유롭게 이동할 수 있습니다.
- 물론 상대경로 방식이 항상 유용한 것은 아닙니다. 예를 들면 내가 디렉토리의 너무 깊숙한 곳까지 이동했다면 어떻게 해야 할까요? 다음과 같이 명령어를 입력해봅시다.
```console
어쩌구@저쩌구:/home$ cd 어쩌구/sampleDirectory                                 # 안쪽 디렉토리로 이동한 뒤,
어쩌구@저쩌구:~/sampleDirectory$ mkdir -p test/test/test/test/test/test/test/  # 하위 폴더 아래에 계속해서 하위 폴더 만들기
어쩌구@저쩌구:~/sampleDirectory$ cd test/test/test/test/test/test/test/
어쩌구@저쩌구:~/sampleDirectory/test/test/test/test/test/test/test$
```
- 여기서 다시 홈 디렉토리(~)까지 이동하려면 ```../```를 한참이나 입력해야겠죠. 아주 귀찮은 일입니다. 이렇게 한참이나 멀리 떨어진 경로를 이동해야 할 때, **절대 경로**가 아주 유용하게 쓰일 수 있습니다.
- 컴퓨터에 있는 모든 디렉토리와 파일은 저마다 정해진 위치 정보가 있습니다. 예를 들면 우리가 위에서 ```pwd```를 쳤을 때 확인했던 ```/home/어쩌구``` 같은 게 그 예죠. 위에서 ```/```는 디렉토리와 디렉토리를 나눠주는 구분 기호라고 말씀 드렸는데요, 여기서 보시면 절대 경로는 항상 가정 첫 ```/```에서부터 시작한다는 걸 알 수 있습니다. 바꿔 말하면 모든 파일과 디렉토리는 가장 첫 번째 ```/```의 하위에 위치하는 것입니다. 이렇게 맨 처음 등장하는 ```/```를 루트(root)라고 부릅니다. 마치 뿌리에서 뻗어나오는 가지처럼, 컴퓨터 안의 모든 파일과 디렉토리는 이 루트에서부터 뻗어나간 뒤 그로부터 제 위치를 배정 받는 것입니다.
- 이번에는 이 절대 경로를 이용해서 홈 디렉토리로 돌아가는 방법을 익혀봅시다. 홈 디렉토리로 한번에 이동하고 싶다면 다음과 같이 입력하면 됩니다.
```console
어쩌구@저쩌구:~/sampleDirectory/test/test/test/test/test/test/test$ cd /home/어쩌구
어쩌구@저쩌구:~$
```
- 여기서 지정해준 ```/home/어쩌구(또는 본인 ID)```가 바로 내 홈 디렉토리의 절대 경로가 됩니다. 그러니 그 깊숙한 곳에서 뿌리에 더 가까운 홈까지 한번에 이동할 수 있었던 것이죠.
- 마찬가지로 홈 디렉토리에서 깊숙하게 있는 안쪽 디렉토리로도 한번에 이동할 수 있습니다. ```cd```를 입력한 뒤 이동하고자 하는 위치의 절대 경로만 입력하면 한번에 이동하게 됩니다.
```console
어쩌구@저쩌구:~$ cd /home/어쩌구/sampleDirectory/test/test/test/test/test/test/test
어쩌구@저쩌구:~/sampleDirectory/test/test/test/test/test/test/test$ 
```
- 그러면 위 예시처럼 위치가 한번에 바뀌게 되죠. ```cd```를 친 다음 단계별로 하나씩 칠 필요가 없는 것입니다.
- 참고로, 홈 디렉토리는 별 다른 위치 정보를 주지 않고도 한번에 이동할 수 있습니다. 아무런 위치 정보를 주지 않고 ```cd```를 치기만 하면 됩니다.
```console
어쩌구@저쩌구:~/sampleDirectory/test/test/test/test/test/test/test$ cd
어쩌구@저쩌구:~$
```

### 커맨드라인 작업에 익숙해지기 위한 보물 찾기
- 이제 가장 기본적인 위치 이동과 파일 내용 확인 관련 명령어에 대해서는 다 알려드렸습니다.
- 하지만 어떤 것이든, 아는 것보다 중요한 건 익숙하게, 능숙하게 사용할 수 있느냐 하는 점이겠죠. 이런 커맨드라인에 익숙해질 수 있도록 보물 찾기 게임을 하나 준비했습니다.
- 이런 게임을 준비한 이유는 그냥 하면 지겨워질 수 있기 때문입니다. 그러니 조금이나마 즐기면서 익숙해질 수 있도록 게임을 준비한 거죠. 마치 예전에 마우스가 보편적이지 않던 시절 지뢰찾기 게임을 통해 마우스 사용법에 익숙해질 수 있었던 것처럼, 커맨드라인 연습용 보물 찾기 게임을 진행하면서 커맨드라인과 친해지시길 바라겠습니다.
- 참고로 이 게임은 제가 만든 건 아니고요, 미국 해양연구소(Marine Biology Labs, 메사추세츠 우즈홀)에서 진행된 실습 과정에서 작성된 게임입니다. 정확히는 캘리포니아 대학 샌프란시스코에 계신 Stephan J Sanders 교수님께서 유닉스 강의를 하기 위해 고안하셨다고 하네요. 당시에 조교로 일하다가 지금은 [고려대학교에서 일하고 계신 안준용 교수님](https://joonanlab.github.io/)께서 한국으로 들여와주셨습니다. 다만 영어가 너무 복잡하고 어렵다 보니 한국어로 제가 번역했고, 조금씩 수정을 가했습니다.
- 게임을 설치하고 싶다면 다음 명령어를 복사하고 터미널에 붙여넣기 하신 뒤 엔터 치시면 됩니다.
```
mkdir 01_treasureHunt && cd 01_treasureHunt
wget https://raw.githubusercontent.com/JunKimCNU/JunKimLabTutorial/main/task01_linux_tutorial/treasureHunt_v2_kor.pl
perl treasureHunt_v2_kor.pl
```
- 그 뒤 ```ls```를 쳐보면 비어있던 디렉토리에 새로운 파일과 새로운 디렉토리가 잔뜩 만들어진 걸 확인할 수 있을 겁니다.
- 참고로 파일 끝에 붙은 ```.pl```은 "Perl"이라는 프로그래밍 언어로 짜인 프로그램이라는 걸 가리키는 것입니다. 이런 파일은 위에서 ```perl treasureHunt_v2_kor.pl```이라고 한 것처럼, ```perl 파일.pl``` 이런 식으로 실행할 수 있습니다. 보물 찾기 중간에 이런 문제가 하나 있으니 기억해두세요.
- 이제 보물 찾기를 시작해봅시다. 보물을 찾아내려면 보물 지도나 단서가 있어야겠죠? 이 게임에서는 "Clue"로 시작하는 파일에 그 단서가 저장돼 있습니다. 첫 번째 단서를 열어봅시다.
```sh
cat Clue01_S.txt
```
- 앞쪽에 헛소리(...)가 잔뜩 나오고 뒤에 실제로 힌트가 적혀 있습니다. 첫 번째 힌트를 예로 들자면 물의 탑(water tower)으로 향하라고 적혀 있는데요, 이 말은 디렉토리 중 ```waterTower``` 디렉토리로 이동하라는 뜻입니다. 힌트에 적힌 "서쪽으로 세 걸음, 남쪽으로 다섯 걸음"이란 말은, ```waterTower``` 디렉토리 하위에 있는 디렉토리 중 ```westThreeSteps```로 이동한 뒤, 다시 ```southFiveSteps```로 이동하라는 뜻입니다. 힌트가 대부분 이런 식이나 잘 따라해보시길 바랍니다.
- 중간중간 다양한 명령어를 활용할 수 있도록 예제가 포함돼 있습니다. 반드시 다양한 명령어를 **검색**하시면서 어떻게 쓰는 것인지 살펴보시길 추천 드립니다. 알려드리지 않은 명령어도 많으니 직접 찾아보셔야 할 겁니다.
- "보물 찾기 종료. 수고하셨습니다!"라는 말이 나와야 끝난 겁니다.
- **보물은 실재합니다. 충남대학교 오시면 제가 커피 한 잔 대접하겠습니다.**
- 보물 찾기가 끝나고 나면 [첫 번째 과제 링크](https://github.com/JunKimCNU/JunKimLabTutorial/tree/main/task01_linux_tutorial)로 들어가셔서 거기 적혀있는 다양한 명령어도 찾아보고 써먹어봅시다.
- 보물 찾기 즐겁게 하시길 바라겠습니다!

## <a name="parsing"></a> 행렬 데이터 다루기
- 보물 찾기 반복 연습 많이 하셨나요? 두세 번쯤 반복하셨다면 충분히 익숙해졌을 겁니다. 이제 커맨드라인에서 쓸 수 있는 다양한 명령어를 좀 더 본격적으로 활용해봅시다.
- 이전 단계인 보물 찾기의 목표는 ```cd```를 비롯한 디렉토리 간 이동에 익숙해지는 것이었습니다.
- 이번 단계의 목표는 ```awk```, ```grep```, ```sed```, ```sort``` 등 데이터를 다루는 데 필요한 다양한 명령어에 좀 더 익숙해지는 것입니다. 실제 유전체 및 생물학 데이터를 다뤄보면서 조금 더 익숙해져보도록 합시다.
- 데이터 분석을 시작하려면 예제 파일을 다운 받아야 합니다. 다음 명령어를 실행해주시기 바랍니다.
```
mkdir 02_parsing_matrix
cd 02_parsing_matrix
wget https://raw.githubusercontent.com/JunKimCNU/JunKimLabTutorial/main/task02_parsing/Assemblytics_structural_variants.bed
```
- 다운로드가 잘 됐다면 화면에 ```‘Assemblytics_structural_variants.bed’ saved [363093/363093]``` 같은 문구가 뜰 겁니다.
- 이제 이 파일을 한번 들여다봅시다. 저는 보통 파일을 확인할 때는 ```ls -l```을 이용해 파일 크기를 체크하고, 너무 크면 아예 ```nano```는 쓸 생각을 하지 않습니다. 그 다음에는 ```head```로 먼저 파일의 첫 10개 줄을 화면에 출력해 살펴봅니다. 더 많은 데이터를 보고 싶다면 ```less```를 이용해 파일을 열어보고요. 순서대로 한번 쭉 따라하면서, ```Assemblytics_structural_variants.bed``` 파일을 들여다봅시다.
- 살펴보셨나요? 들여다보면 알겠지만, 이 파일은 행렬(matrix) 형태를 이루고 있습니다. 각 열(column)과 열 사이를 나누는 기호는 탭(tab)입니다. 이처럼 탭으로 나뉜 파일 형식을 TSV (tab-separated values)라고 부릅니다.
- 이 파일은 [BED](https://genome.ucsc.edu/FAQ/FAQformat.html)라는 생물학에서 굉장히 널리 쓰이는 포맷을 따르고 있기도 합니다. 이 BED 포맷은 다양한 정보를 담을 수 있는데요, **변이**(variant)에 대한 정보를 담아낼 때 아주 유용하게 쓰입니다. 기본적으로는 첫 번째 열에는 **염색체 이름**이, 두 번째 열에는 **그 염색체에서 시작되는 위치**가, 세 번째 열에는 **그 염색체에서 끝나는 위치**가, 그리고 나머지 열에는 다양한 정보가 기록되게 되어있고요, 이를 이용해 다양한 변이에 대한 정보를 효율적으로 담아낼 수 있습니다.
- DNA가 잘려나가거나 끼어들어간 결손과 삽입 돌연변이 같은 경우를 예로 들어봅시다. 염색체 1번의 300 bp 지점부터 350 bp 지점까지 DNA가 잘렸고 염색체 2번은 500 bp 지점에 100 bp의 DNA가 추가로 끼어들어갔다고 쳐봅시다. 이는 예를 들면 다음과 같은 BED 포맷으로 저장될 수 있습니다.
```
#chromosome	start	end	type	size
chr1	300	350	deletion	50
chr2	500	500	insertion	100
```
- 이 행렬은 첫 번째 열에 염색체 정보, 두 번째 열에 변이가 시작하는 위치, 세 번째 열에 변이가 끝나는 위치, 네 번째 열에 변이의 유형, 다섯 번째 열에 그 변이의 크기가 담겨있는 데이터가 됩니다. 그러면 변이에 대한 다양한 정보를 담은 자료가 만들어지는 셈이죠. 이처럼 BED 포맷은 다양한 생물학 분석에 쓰이기 때문에, 간단하게나마 알아두는 것이 좋습니다.
- 다시 ```Assemblytics_structural_variants.bed``` 파일로 돌아가봅시다. 이 파일은 **구조 변이**(structural variant)라고 부르는 특정한 형태의 변이 정보를 담고 있는 파일입니다. 앞에서 언급한 삽입, 결손과 같은 돌연변이를 포함해 DNA가 크게 바뀐 변이를 가리킵니다. 현재는 50 bp 이상 바뀐 것을 구조 변이라고 부르고 있습니다.
- 또 구조 변이란 2개 이상의 유전체를 비교해서 얻어내는 정보입니다. 보통은 참조 유전체(reference genome)에 비교 대상이 되는 유전체(query genome)를 비교함으로써, 참조 유전체 기준으로 염색체의 어떤 지역에 삽입/결손과 같은 돌연변이가 존재하는지를 확인할 수 있게 해줍니다.
- 이제부터는 이 구조 변이 정보를 담은 BED 파일을 자세하게 들여다보는 연습을 해보겠습니다.
- 먼저 파일 형식에 대해 이해해봐야겠죠? 이 파일의 맨 첫 번째 줄에는 위 예제와 마찬가지로 각 열의 정보가 담겨있습니다. 이처럼 값이 아닌 정보를 담고 있는 행(row)을 헤더(header)라고 부릅니다. 헤더를 뽑는 명령어는 다음과 같이 쓸 수 있습니다.
```console
어쩌구@저쩌구:~/02_parsing_matrix$ head -1 Assemblytics_structural_variants.bed
reference	ref_start	ref_stop	ID	size	strand	type	ref_gap_size	query_gap_size	query_coordinates	method
```
- 각 구조 변이에 대한 정보는 각 행에 담기게 되는데, 한 행의 각 열에는 다음과 같은 정보가 담기게 됩니다. 하나의 구조 변이에 대해, 첫 번째 열에는 참조 유전체 기준 염색체 정보, 두 번째 열에는 그 염색체에서 구조 변이가 시작되는 위치, 세 번째 열에는 그 구조 변이가 끝나는 위치 등이 기본적으로 담기죠. 그리고 다섯 번째 열에는 그 구조 변이에 부여한 이름(ID)이, 여섯 번째 열에는 그 구조 변이의 크기(size)가 담기며, 방향(strand)과 유형(type) 같은 정보도 담기게 됩니다.
- 이런 정보를 이용해 수많은 구조 변이 중 우리가 원하는 것만 쏙쏙 뽑아 들여다볼 수 있습니다.
(QUIZ) 먼저 이 파일에 몇 개의 구조 변이 정보가 담겨있는지를 살펴봅시다. 이전 과제를 잘 해결했다면, 제가 넣어둔 명령어 목록 중에서 ```wc```를 잘 활용하면 이 정보를 알아낼 수 있다는 걸 이해하실 수 있을 겁니다.
- 정답은 3,398개입니다. 헤더는 구조 변이 정보를 담고 있지 않으니 1개 빼야 한다는 걸 신경 써주세요.
- 이 파일에 담겨 있는 구조 변이의 유형(type)은 뭐가 있는지도 알아보면 좋겠죠? 일곱 번째 열에 그 정보가 담겨 있을 겁니다. 그러면 일곱 번째 열을 뽑는 명령어를 활용해봅시다. 다양한 명령어가 있습니다만, 저는 주로 ```awk```를 활용하고 있습니다만, ```cut```을 이용해도 좋습니다. 3천 줄이나 화면에 출력되면 귀찮을 테니, ```head```를 이용해 앞에서 10개만 뽑아봅시다.
```console
어쩌구@저쩌구:~/02_parsing_matrix$ awk '{print $7}' Assemblytics_structural_variants.bed | head
어쩌구@저쩌구:~/02_parsing_matrix$ cut -f 7 Assemblytics_structural_variants.bed | head
```
- 위 두 명령어는 동일한 결과를 줄 겁니다. "type", "Insertion", "Deletion"이 마구 뒤섞인 결과를 말이죠. 이 열에 뒤섞여 있는 정보를 정렬하고, 중복되는 정보를 제거하면 전체 구조 변이 유형이 몇 종류나 있는지 알기 좋을 겁니다. 이럴 때는 ```sort```와 ```uniq```를 이용하면 좋습니다. 이때는 ```head```는 빼시면 되겠습니다.
```console
어쩌구@저쩌구:~/02_parsing_matrix$ awk '{print $7}' Assemblytics_structural_variants.bed | sort | uniq
어쩌구@저쩌구:~/02_parsing_matrix$ cut -f 7 Assemblytics_structural_variants.bed | sort | uniq
```
- 그러면 이 BED 파일에는 총 6가지 유형의 구조 변이가 있다는 걸 알 수 있을 겁니다. Deletion, Insertion, Repeat_contraction, Repeat_expansion, Tandem_contraction, Tandem_expansion이 그것이죠. 이런 식으로 데이터를 확인해볼 수 있는 겁니다.

### 집중해주세요!
- 뜬금 없지만 여기서 정말 중요한 말씀을 드리고 싶은데요, 세상에는 동일한 결과를 내주는 수많은 명령어 조합, 코드 조합이 존재합니다. 그리고 생물학자로서 데이터를 다룰 때는 거의 모든 경우에, **뭔 삽질을 하든, 얼마나 돌아서 가든, 결과만 정확하다면 아무 문제가 없습니다**.
- 이는 생물학에서 다루는 수많은 문제들은 처리하는 속도가 그렇게 중요하지 않기 때문입니다. 유전체 데이터는 당연히 엄청나게 크지만, 앞으로 배울 프로그램들을 잘 활용할 수만 있다면 시간이 오래 걸리는 부분은 모두 아주 쉽게 해결됩니다. 위대하신 분들이 이미 복잡한 프로그램을 모두 개발해서 세상에 공짜로 뿌려두셨기 때문입니다. 우리가 할 일은 그 프로그램에서 나온 결과물을 다루는 일이 됩니다. 그리고 이렇게 전처리가 끝난 데이터는 보통 수천 줄에서 수십만 줄 수준밖에 되지 않습니다. 물론 많은 양이고, 직접 눈으로 들여다본다면 몇 시간, 아니 몇 십 시간이 들겠죠. 그렇지만 컴퓨터를 이용하면 아무리 느려도 5초면 끝날 겁니다. 삽질을 수백 번해서 잘못 처리한다고 해도 수천 초, 1-2시간밖에 걸리지 않을 테죠. 게다가 여러분의 실력은 점점 늘 겁니다. 그러면 그렇게 쓰이는 시간은 점점 짧아져 어떤 데이터든 원하는 대로 몇 초만에 처리할 수 있게 됩니다.
- 그러니 **이상한 명령어 조합 또는 한참이나 돌아가는 명령어 조합을 쓰는 것을 결코 두려워하지 마세요.** 뭔 결과를 내든 여러분이 눈으로 들여다보는 것보다는 빠르고, 그렇게 삽질하다 보면 점점 좋은 방식으로 나아갈 수 있을 겁니다.
- 물론 제 연구실 사람이라면 작성한 명령어 조합 등을 정리해서 보여주시길 바라겠습니다. 좀 더 효율적인 명령어 조합 등을 알려드리겠습니다. 또 박사과정 하다 보면 수십억 줄은 되는 데이터를 다루게 될 때도 있을 텐데요, 그런 데이터라면 제가 코드를 짜드리거나 스스로 짤 수 있도록 도와드릴 테니 걱정 안 해도 됩니다. 성장하는 데 집중하시길 바랍니다.

- 이번에는 참조 유전체(reference genome)에 대해서도 간략하게 살펴봅시다. 참조 유전체란 특정한 생물 종의 DNA 정보를 고품질로 확보해둔 것입니다. 가장 초기에는 생어 시퀀싱 기법 등을 이용해서 제작했고, 한때는 숏리드 시퀀싱 기법을 이용해서 많이들 제작했지만, 요새는 거의 모든 사람들이 롱리드 시퀀싱 기법을 이용해 다양한 생물의 유전체 지도를 작성하고, 이를 참조 유전체로 활용하고 있습니다.
- 먼저 예제 데이터를 다운 받아야 합니다. 다음 명령어를 입력해주시기 바랍니다.
```
wget -O ceN2.fa.gz https://downloads.wormbase.org/releases/WS289/species/c_elegans/PRJNA13758/c_elegans.PRJNA13758.WS289.genomic.fa.gz
gzip -d ceN2.fa.gz
```
- 이 데이터는 다세포생물 중 가장 처음으로 유전체 지도가 완성된 생물인 예쁜꼬마선충(*Caenorhabditis elegans*)의 참조 유전체 데이터입니다. ```wget```은 웹에서 데이터를 다운 받을 때 많이 쓰는 명령어이고, ```gzip```은 압축하거나 압축 풀 때 쓰는 명령어입니다. 각각 ```-O```와 ```-d```가 붙어있는데, 이런 옵션들이 무슨 역할을 하는지는 "help" 페이지를 읽어보거나 해당 내용을 검색해서 공부해봅시다.
- 파일을 다운 받았으니, 마찬가지로 ```ls -l``` 등을 이용해서 데이터 크기를 살펴봅시다. 매우 크니까 ```nano``` 같은 텍스트 에디터를 이용해서 ```ceN2.fa```라는 파일을 여는 것은 권하지 않습니다. 파일이 워낙 크다 보니 그대로 컴퓨터가 한동안 멈춰버릴 겁니다. ```less``` 등으로 파일을 열어보시기 바랍니다.
- 그러면 DNA 정보가 FASTA 형식으로 쭉 적혀 있는 걸 볼 수 있을 겁니다. 참고로 파일 이름이 ```*.fa```로 되어있는데요, 이렇게 ```.fa```로 끝나는 파일은 FASTA 포맷이라는 걸 가리킵니다. FASTQ 포맷은 보통 ```*.fq``` 등으로 적혀 있습니다.
- 파일 앞쪽을 ```head```를 이용해 열어 봅시다.
```console
어쩌구@저쩌구:~/02_parsing_matrix$ head ceN2.fa
>I
GCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAA
GCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAA
GCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAA
GCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAA
GCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAA
GCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAA
GCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAAGCCTAA
GCCTAAGCCTAAAAAATTGAGATAAGAAAACATTTTACTTTTTCAAAATTGTTTTCATGC
TAAATTCAAAACGTTTTTTTTTTAGTGAAGCTTCTAGATATTTGGCGGGTACCTCTAATT
```
- 그러면 예쁜꼬마선충의 1번 염색체 왼쪽 끝에 담긴 서열 정보가 나타나게 됩니다. 이전에도 말씀 드렸듯 ```>``` 표시는 해당 서열의 이름이 그 줄에 나온다는 뜻이 되고, 여기서는 ```I```이 염색체의 이름이 됩니다. 앞쪽에는 ```GCCTAA```가 반복해서 나타나는데요, 이는 예쁜꼬마선충의 텔로미어 반복서열인 TTAGGC가 reverse complement되어있는 형태입니다. 보통 진핵생물의 유전체 지도가 염색체 수준으로 잘 완성돼 있다면, 이처럼 왼쪽 끝과 오른쪽 끝에 모두 텔로미어 반복서열이 cluster를 이루며 등장하게 됩니다.
- 이번에는 이 파일을 이용해 염색체 정보를 뜯어보는 연습을 좀 더 해봅시다. 먼저 이 참조 유전체에 들어있는 염색체 또는 염색체의 일부 조각 개수가 얼마나 되는지 살펴보도록 합시다. 어렵지 않게 살펴볼 수 있는데요, FASTA 포맷에서는 모든 DNA 정보의 이름에 ```>```가 포함되어있기 때문입니다. 그러니 ```>```의 개수만 세면, 염색체나 기타 등등 DNA 조각이 몇 개나 있는지 알 수 있죠. 다음 명령어를 입력해봅시다.
```console
어쩌구@저쩌구:~/02_parsing_matrix$ grep ">" ceN2.fa
>I
>II
>III
>IV
>V
>X
>MtDNA
```
- 그러면 위와 같이 DNA의 이름 정보가 쭉 출력될 겁니다. 참고로 예쁜꼬마선충은 상염색체를 5개, 성염색체를 1개, 미토콘드리아 염색체를 1개 지니고 있습니다. 각각 I, II, III, IV, V, X, MtDNA라는 이름이 붙어있고요.
### 집중해주세요!
- 여기서 한 가지 주의할 사항을 말씀 드리려고 합니다. ```>``` 문자를 사용할 때는, 이게 **리디렉션으로 인식될 수 있다**는 점을 반드시 주의하셔야 합니다. 컴퓨터에서 이 기호가 리디렉션으로 잘못 인식되면 **작업하려던 파일이 빈 파일이 되는 참사**가 일어날 수 있기 때문입니다.
- 예를 들면 ```grep ">" ceN2.fa```라고 쳐야 하는데, 쌍따옴표를 빼먹어서 ```grep > ceN2.fa```라고 쳤다고 해봅시다. 이러면 ```>```가 ```grep```의 검색 대상이 아닌 리디렉션으로 인식되게 됩니다. ```grep```의 결과를 ```ceN2.fa```라는 파일 이름으로 저장하라는 명령어가 되는 셈이죠. 그리고 이렇게 되면 ```ceN2.fa``` 파일은 곧장 빈 파일이 되어버리게 됩니다.
- 이유는 다음과 같습니다. ```grep > ceN2.fa```라는 명령어를 보면, 마치 앞에서부터 차례대로 실행될 거라고 생각하기 쉽습니다. 다시 말해 ```grep```으로 뭔가를 하려고 한 다음, 그 결과가 STDOUT으로 나오면 이를 STDIN으로 리디렉션해서 ```ceN2.fa```라는 파일에 저장하라는 식으로 말이죠. 이 경우라면 별 문제가 없을지도 모릅니다. 왜냐면 ```grep```은 각 행을 검색해서 우리가 검색하고 싶은 문자열이 있는지를 확인하는 명령어인데, ```grep > ceN2.fa```라는 명령어에서 ```>```가 리디렉션으로 인식됐다면 ```grep```에는 검색할 문자열도, 검색할 파일도 지정이 되지 않았으니 그냥 헬프 페이지를 띄우겠죠.
- 문제는 이 **실행 순서가 정반대**로 일어난다는 데 있습니다. 요컨대 ```grep > ceN2.fa```라는 명령어가 실행되면, 일단 다짜고짜 ```ceN2.fa```라는 **빈 파일을 새로 생성**합니다. 그 다음에 ```grep```을 실행하죠. 그러면 짜잔! 분석하려던 데이터가 싹 날아가고 ```grep```은 헬프 페이지를 띄워줍니다.
```console
어쩌구@저쩌구:~/02_parsing_matrix$ grep > ceN2.fa
Usage: grep [OPTION]... PATTERNS [FILE]...
Try 'grep --help' for more information.
어쩌구@저쩌구:~/02_parsing_matrix$ cat ceN2.fa
어쩌구@저쩌구:~/02_parsing_matrix$                  # 파일이 텅 비어서 아무것도 출력하지 않음.
```
- 분석하려던 파일이 쉽게 복구할 수 있는 것이라면 별 타격이 없겠지만, 몇날며칠 고생해서 정리해둔 데이터라면 진짜 피눈물 납니다. 조심 하시기 바랍니다.

- 이번 단계에서 배워야 할 건 이 정도면 끝난 것 같습니다. 마찬가지로 [두 번째 과제](https://github.com/JunKimCNU/JunKimLabTutorial/tree/main/task02_parsing)를 한번 따라해보시면서 좀 더 익숙해지시길 바라겠습니다.

## <a name="conda"></a> Conda를 이용한 프로그램 설치
- 지금까지 가장 기본적인 명령어들을 이용해서 커맨드라인과 간단한 행렬 데이터 처리에 익숙해지는 과정을 거쳤습니다. 이번 단계에서는 좀 더 본격적인 프로그램들을 사용하는 방법들에 대해 익혀봅시다.
- 프로그램을 활용하는 데 있어서 가장 큰 걸림돌이 되는 것 중 하나는 설치가 쉽지 않았다는 점입니다. 하지만 이제는 [Conda](https://docs.conda.io/en/latest/)나 [Docker](https://www.docker.com/), [Singularity](https://sylabs.io/singularity/) 등 다양한 기법들이 개발되면서 프로그램 설치가 아주 쉬워졌습니다. 프로그램 설치까지만 되면 본인 데이터만 잘 활용해서 프로그램을 돌리기만 하면 끝나거든요. 우리가 할 일은 이런 기법들을 활용해 원하는 프로그램을 설치하고 그 프로그램을 잘 쓰는 수준이면 충분합니다.
- 이러한 다양한 기법 중에 가장 보편적으로 쓰이는 프로그램 설치법 중 하나는 Conda입니다. Conda를 쓰면 프로그램마다 각자의 **환경**(environment)을 부여할 수 있는데, 이렇게 하면 프로그램들끼리 **충돌**하지 않고 쉽게 설치된다는 강력한 장점이 있습니다. 환경이랑 충돌이라는 게 뭔지는 이제부터 설명 드리겠습니다.
- 이전에 프로그램들을 설치하기 어려웠던 이유는, 프로그램들마다 서로 다른 작동 환경을 필요로 했기 때문입니다. 환경이란 프로그램이 작동하기 위해 필요한 다양한 하위 프로그램, 라이브러리 등을 가리킨다고 보시면 됩니다. 2개 이상의 서로 다른 프로그램이 있어야 데이터 분석을 하는데, 그 두 프로그램들이 작동하는 환경이 서로 배타적이라면 2개 프로그램을 동시에 설치할 수 없었던 겁니다.
- 분자생물학 실험으로 비유하자면 제한효소 2개를 써서 DNA를 잘라야 하는데, 이 2개의 제한효소를 작동시킬 수 있는 버퍼는 세상에 존재하지 않는 상황이랑 비슷합니다. 별 수 있나요? 실험을 나눠서 하든지 해서, 두 제한효소가 서로 다른 화학적 환경에서 작동하도록 하는 수밖에 없죠. 프로그램 설치도 이랬습니다.
- 예를 들면 이런 겁니다. 프로그램 1은 라이브러리 A의 버전 1.9가 있어야 하는데, 프로그램 2는 라이브러리 A의 버전이 3.0은 되어야 한다고 생각해봅시다. 그러면 내 컴퓨터에 프로그램 1과 프로그램 2를 동시에 설치하려면, 라이브러리 A는 대체 어떤 버전을 써야 하는 걸까요? 라이브러리 A의 버전을 1.9로 맞추자니 프로그램 2를 쓸 수가 없고, 반대로 3.0으로 맞추면 프로그램 1을 쓸 수가 없는 문제가 생깁니다. 이런 문제 때문에 컴퓨터 안에 엄청나게 다양한 라이브러리를 버전마다 다 따로 설치하고, 프로그램마다 따로따로 라이브러리를 짝지어줘야 했는데, 이 작업이 보통 귀찮은 게 아니었습니다. 그러니 설치가 쉽지 않아 프로그램을 돌려보지도 못하고 포기하는 일이 부지기수였죠.
- Conda는 이런 문제를 손쉽게 해결해줍니다. Conda를 활용하면 프로그램마다 서로 다른 환경을 부여해 각자에게 필요한 라이브러리 등을 짝지어주는 게 아주 쉬워집니다. 예를 들면 Conda를 활용하면, 환경 1을 만들어 라이브러리 A 버전 1.9와 프로그램 1을 설치하고, 동시에 같은 컴퓨터에 환경 2를 만들어 라이브러리 버전 3.0과 프로그램 2를 설치하는 게 **명령어 두 줄**이면 가능합니다. 엄청나게 편해진 거죠.
- 그럼 지금부터 이 Conda를 서버에 설치하고, 이를 활용해 다양한 생물학 관련 프로그램들을 설치하는 과정을 한번 따라가봅시다. [Conda 홈페이지](https://docs.conda.io/en/latest/miniconda.html)에서 본인 운영체제에 맞는 걸 골라 다운로드 하고 설치해봅시다.
- 저처럼 Ubuntu 운영체제를 사용한다면 다음 단계를 따르시면 됩니다. 다른 운영체제는 제가 안 해봐서 모르겠어요. 찾아보셔야 할 것 같습니다.
```
cd
mkdir 03_conda && cd 03_conda
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh   # 인스톨러 다운로드
bash Miniconda3-latest-Linux-x86_64.sh                                       # 인스톨러 실행. *.pl을 perl로 실행했던 것처럼, *.sh 파일은 bash로 실행하면 됩니다.
```
- 이렇게 하면 엔터 치고 약관 읽으라는 말이 나올 겁니다. 엔터를 치면서 내리시면 되고, 동의하시면 yes 치시면 됩니다.
- 그 뒤 어디에 설치할지 설치 경로를 물어보는데, 원하는 곳 지정하시면 되겠습니다.
- 마지막으로 Conda 실행에 필요한 초기 설정을 하겠냐고 물어보는데, yes 고르시면 됩니다.
- 그러면 화면에 뭐가 엄청나게 뜰 겁니다. 터미널로 돌아오고 나면, 다음과 같이 입력하고 난 뒤 터미널이 변화하는지 확인하시면 됩니다.
```console
어쩌구@저쩌구:~/03_conda$ bash ~/.bashrc           # Conda 관련된 기본 환경을 작동시켜줌.
(base) 어쩌구@저쩌구:~/03_conda$                   # 왼쪽에 (base)가 뜨면 성공
```
- 이제 Conda 설치가 끝났습니다. 쉽죠? 이제는 ```conda```라는 명령어를 활용할 수 있게 됐습니다. 마찬가지로 터미널에 다음과 같이 쳐서 헬프 페이지가 잘 나오는지 확인해봅시다.
```console
(base) 어쩌구@저쩌구:~/03_conda$ conda
usage: conda [-h] [-V] command ...
[후략]
```
- (base)라고 적힌 부분이 현재 작업 중인 Conda 환경의 이름을 보여주는 부분입니다. 현재 환경은 (base)라는 말 그대로 가장 기반이 되는 기본 환경이라는 뜻이 되겠습니다. 이후에 새로운 환경을 만들고 그 환경을 활성화시키면, 예를 들면 (assembly), (rnaseq) 등등으로 (base) 부분이 바뀌게 될 겁니다. 한 가지 작업만 더 해놓고 바로 새로운 환경을 만들어봅시다.
- Conda가 잘 설치됐다면, 이번에는 Mamba를 설치할 차례입니다. Conda는 참 좋은 도구이지만 몇 가지 문제가 있는데요, 그 중 하나가 프로그램을 여러 개 동시에 설치하려고 하면 시간이 엄청나게 오래 걸리고 잘 안 된다는 점입니다. 이런 문제를 해결해주는 게 Mamba입니다. Mamba를 활용하면 다양한 프로그램이 아주 빠르게 설치됩니다.
- 앞으로 더 자세하게 말씀 드리겠습니다만, 앞으로는 ```conda``` 명령어 대신 ```mamba``` 명령어를 쓰시면 됩니다.
- Mamba를 설치하고 싶으시면 마찬가지로 [공식 홈페이지에서 알려주는 설치 방법](https://mamba.readthedocs.io/en/latest/installation.html)을 따르시면 됩니다. 2023년 7월 6일 현재에는 다음 명령어를 입력해서 Mamba를 설치할 수 있습니다. 중간에 y 한 번 눌러서 설치 진행해주세요.
```console
(base) 어쩌구@저쩌구:~/03_conda$ conda install -n base --override-channels -c conda-forge mamba 'python_abi=*=*cp*'
[중략]
(base) 어쩌구@저쩌구:~/03_conda$ mamba
usage: mamba [-h] [-V] command ...
[후략]
```
- 위에 보이는 것처럼 설치가 끝나면 이제 ```mamba```를 치기만 하면 헬프 페이지가 나오게 될 겁니다. 다음 명령어도 쳐줍시다.
```console
(base) 어쩌구@저쩌구:~/03_conda$ mamba init
(base) 어쩌구@저쩌구:~/03_conda$ source ~/.bashrc
```
- 이제 모든 준비는 끝났습니다. 이제 새로운 환경을 만들어봅시다. 다음과 같이 명령어를 쳐주세요.
```console
(base) 어쩌구@저쩌구:~/03_conda$ mamba create -n basicGenomics
```
- 마찬가지로 설치하겠냐는 말이 나올 텐데 y 누르고 엔터 치면 됩니다. 환경이 새롭게 만들어졌습니다. 이제 이 환경을 활성화시켜봅시다.
```console
(base) 어쩌구@저쩌구:~/03_conda$ mamba activate basicGenomics
(basicGenomics) 어쩌구@저쩌구:~/03_conda$ 
```
- 그러면 위에 보이는 것처럼, 왼쪽에 환경 이름을 보여주는 곳이 (basicGenomics)로 바뀌게 될 겁니다.
- 이제 이 환경에서 새로운 프로그램들을 설치할 수 있고요, 설치가 끝나면 자유롭게 쓸 수 있습니다. 다음과 같이 명령어를 입력해줍시다.
```console
(basicGenomics) 어쩌구@저쩌구:~/03_conda$ mamba install -c conda-forge -c bioconda assembly-stats samtools bioawk seqtk hisat2 bedtools bcftools bwa fastqc minimap2 hifiasm svim svim-asm busco
# 참고: conda-forge 또는 bioconda는 다양한 프로그램이 공개돼있는 채널입니다. Mamba는 이러한 채널을 뒤져서 가장 적합한 프로그램들을 죄다 긁어모다 자동으로 내가 제공한 프로그램 리스트를 설치해줍니다.
# 여기서 설치시킨 프로그램은 총 14개입니다(assembly-stats, samtools, bioawk, seqtk, hisat2, bedtools, bcftools, bwa, fastqc, minimap2, hifiasm, svim, svim-asm, busco).
```
- 이렇게 입력하고 나서 y를 치면 우리가 앞으로 분석에 쓸 프로그램이 **한번에** 그리고 **자동으로** 설치됩니다. 참 쉽죠? 제 서버에서는 **5.5초**만에 설치가 끝났네요.
- 혹시 내가 쓰고 싶은 프로그램이 더 있다면 직접 검색해보시면 됩니다. 검색창에 "(프로그램이름) bioconda" 등으로 검색하면 "anaconda" 또는 "bioconda" 웹페이지가 나올 겁니다. 예를 들면 "bwa bioconda"라고 검색하시면 [이런 페이지](https://anaconda.org/bioconda/bwa)가 검색될 텐데요, 이 페이지에 적힌 설치 방법을 따라하시면 됩니다. 정확히는 ```conda install -c bioconda bwa```라고 적혀 있는데, 여기서 ```conda```만 ```mamba```로 바꿔주시면 됩니다. ```mamba install -c bioconda bwa``` 이런 식으로 말이죠.

### 집중해주세요!
- Conda의 또 다른 문제점은 **base 환경에 프로그램을 설치하다 보면 기존에 깔린 모든 conda 환경이 망가질 가능성이 존재한다**는 것입니다. 이렇게 되면 프로그램 싹 다 다시 설치해야 돼서 진짜 열받겠죠? 게다가 논문 쓰던 도중이라면 프로그램 버전이 바뀌지 않도록 신경 써야 하는데, 프로그램을 재설치하다 보면 버전까지 바뀔 수 있다 보니 정말정말 고통스러워질 수 있습니다. 논문 쓸 때는 프로그램 버전도 다 기록을 해줘야 하거든요.
- 그러니 **새로운 프로그램을 설치하고 싶다면 반드시 새로운 환경을 먼저 생성합시다. 그 다음에 그 환경을 활성화시킨 뒤 새로운 프로그램을 설치하도록 합시다.** 그래야 인생이 피곤해지는 일을 덜 마주칠 수 있습니다.

- 작업이 다 끝났다면 원래 환경으로 돌아가볼까요? 다음과 같이 진행해봅시다.
```console
(basicGenomics) 어쩌구@저쩌구:~/03_conda$ mamba deactivate
(base) 어쩌구@저쩌구:~/03_conda$
```
- 그러면 다시 원래 환경으로 돌아오게 될 겁니다.
- 이번에는 새로운 환경에 다른 프로그램도 설치해봅시다.
```console
(base) 어쩌구@저쩌구:~/03_conda$ mamba create -n repeat
(base) 어쩌구@저쩌구:~/03_conda$ mamba activate repeat
(repeat) 어쩌구@저쩌구:~/03_conda$ mamba install -c conda-forge -c bioconda repeatmodeler
# 혹시 설치 안 되면,
(repeat) 어쩌구@저쩌구:~/03_conda$ conda update -n base conda
# conda를 업데이트한 뒤 다시 다음 명령어를 실행해주세요.
(repeat) 어쩌구@저쩌구:~/03_conda$ mamba install -c conda-forge -c bioconda repeatmodeler
```
- 이제 또 다른 프로그램이 설치됐습니다. 이번에만 그런 건지는 모르겠지만, 저는 이 ```repeatmodeler```가 다른 프로그램과는 동시에 설치가 안 되더라고요. 이런 식으로 동시에 설치되지 않는 충돌이 벌어지더라도, 새로운 환경에 설치하면 아무 문제 없습니다. 아주 편한 세상입니다.
- 이번 단계에서는 이 정도 하면 된 것 같습니다. 다음 단계부터는 이번에 설치한 다양한 프로그램들을 하나하나씩 써먹어봅시다.
- 이번 단계 과제는 별 건 없습니다. [다음 질문](https://github.com/JunKimCNU/JunKimLabTutorial/tree/main/task03_conda/README.md)을 읽고 답을 검색해서 알아둡시다.

## <a name="basic_programs"></a> 기본적인 프로그램 다뤄보기
- 이번 단계에서는 이전에 Conda를 이용해 설치한 다양한 프로그램들을 하나씩 다뤄봅시다.
- 가장 먼저 써볼 프로그램은 [bioawk](https://github.com/lh3/bioawk)입니다. 시퀀싱과 관련된 다양한 데이터 포맷을 다룰 때 쓸 수 있는 프로그램이고, 유용한 기능이 많습니다. 먼저 다음과 같이 쳐봅시다.
```console
(base) 어쩌구@저쩌구:~$ mkdir 04_basic_programs && cd 04_basic_programs
(base) 어쩌구@저쩌구:~/04_basic_programs$ bioawk
bioawk: command not found
```
- 위에 보이는 것처럼, (base) 상태에서 ```bioawk```를 검색하면 프로그램이 작동하지 않습니다. 이전에 말씀 드렸듯, ```bioawk```를 설치한 건 (basicGenomics)라는 특정한 환경이기 때문입니다. 그러니 프로그램을 쓰기 전에 그 환경을 먼저 활성화시켜줘야겠죠. 다음과 같이 진행해봅시다.
```console
(base) 어쩌구@저쩌구:~/04_basic_programs$ mamba activate basicGenomics
(basicGenomics) 어쩌구@저쩌구:~/04_basic_programs$ bioawk
usage: bioawk [-F fs] [-v var=value] [-c fmt] [-tH] [-f progfile | 'prog'] [file ...]
```
- 위에 보이는 것처럼 ```bioawk```의 사용법 정보가 나오면 성공입니다. Conda를 통해 제대로 설치가 됐다는 뜻이죠.
- 이제 ```bioawk```를 이용하는 방법을 몇 가지 배워봅시다.
- ```bioawk```는 기본적으로는 ```awk```와 거의 똑같이 돌아간다고 보시면 됩니다. 중요한 차이는 ```awk```가 행렬로 이뤄진 파일의 내용을 직접적으로 다룬다면, ```bioawk```는 **시퀀싱 관련 데이터를 행렬처럼 바꿔서 다룬다**는 것입니다. 조금 더 자세하게 설명 드리도록 하겠습니다.
- 이전에 써본 것처럼, ```awk```는 행렬을 다룹니다. 각 행(row)에 있는 여러 열(column)에 대해 다양한 연산을 처리해서 그 결과를 보여주죠. 예를 들면 ```awk '{print $1}' file.txt```라는 명령어를 입력하면 첫 번째 열의 정보를 화면에 프린트해주고, ```awk '{print $23}' file.txt```라는 명령어를 입력하면 스물세 번째 열의 정보를 출력해주는 식입니다.
- ```awk```는 어떤 파일을 집어넣든, 그 **파일의 내용을 행렬로 인식**해서 처리해주는데요, 보통 각 열을 구분하는 방식은 **필드 구분 문자**(field separator)를 중심으로 이뤄집니다. 기본적으로는 빈칸을 구분 문자로 인식하기 때문에 사람이 인식하는 것과 비슷하게 빈칸이 있으면 새로운 열이라고 인식하는 식이죠. 구분 문자를 직접 지정해줄 수도 있습니다. 예를 들면 ```awk -F "TT" '{print $1,$2,$3}'```라는 명령어를 입력하면, 스페이스건 탭이건 빈칸은 전부 무시하고 TT가 나올 때만 열로 구분해준 뒤, 1번 2번 3번 열의 정보를 출력해줍니다. 실제로 해봅시다.
```console
(basicGenomics) 어쩌구@저쩌구:~/04_basic_programs$ echo "ATTGCCTAATTCG" > awk.test1.txt
(basicGenomics) 어쩌구@저쩌구:~/04_basic_programs$ awk -F "TT" '{print $1,$2,$3}' awk.test1.txt
A GCCTAA CG
```
- ```awk```는 이런 식으로, 우리가 입력해준 **구분 문자를 활용해 데이터를 행렬로 변환하고 처리**하는 것이죠.
- ```bioawk```도 매우 비슷하게 작동합니다. ```awk```와 다른 점은, ```bioawk```는 **지정해준 포맷에 맞춰 데이터를 행렬로 변환하고 처리**해준다는 것입니다.
- 예제의 결과를 들여다보면서 ```bioawk```가 작동하는 방식을 이해해봅시다. 다음과 같이 명령어를 입력해주세요.
```console
(basicGenomics) 어쩌구@저쩌구:~/04_basic_programs$ echo -e ">testSeqName1\nATTGCCTAATTCG\n>testSeqName2\nAAGTCGATCGATCG" > bioawk.test1.txt  # 간단한 FASTA 파일 생성
(basicGenomics) 어쩌구@저쩌구:~/04_basic_programs$ cat bioawk.test1.txt                                      # 파일 내용 확인
>testSeqName1
ATTGCCTAATTCG
>testSeqName2
AAGTCGATCGATCG
(basicGenomics) 어쩌구@저쩌구:~/04_basic_programs$ bioawk -c fastx '{print $name}' bioawk.test1.txt         # FASTA 파일을 행렬로 변환해 "이름"에 대한 정보 추출
testSeqName1
testSeqName2
(basicGenomics) 어쩌구@저쩌구:~/04_basic_programs$ bioawk -c fastx '{print $seq}' bioawk.test1.txt          # FASTA 파일을 행렬로 변환해 "서열"에 대한 정보 추출
ATTGCCTAATTCG
AAGTCGATCGATCG
(basicGenomics) 어쩌구@저쩌구:~/04_basic_programs$ bioawk -c fastx '{print $qual}' bioawk.test1.txt         # FASTA 파일을 행렬로 변환해 "퀄리티"에 대한 정보 추출


(basicGenomics) 어쩌구@저쩌구:~/04_basic_programs$
```
- 그러면 위와 같은 결과가 나올 겁니다. 기본적으로 ```bioawk```를 활용하려면, 내가 입력하는 파일을 어떤 포맷으로 인식해야 하는지를 ```bioawk```에게 알려줘야 합니다. 그게 ```-c fastx```라고 적힌 부분입니다. 이러면 내가 입력하는 파일 포맷이 FASTA 또는 FASTQ이니, 그에 맞게 처리해달라고 ```bioawk```에게 명령하는 셈이 됩니다. 이제 ```bioawk```는 입력 파일을 FASTA/Q 포맷에 맞춰서 적절하게 행렬로 변환해주죠. 그리고 각 열을 가리키는 것은 **name**, **seq**, **qual** 등이 되게 됩니다. (물론 현재 입력 파일은 FASTA 파일이라 퀄리티 정보는 없으니 해당 값은 처리되지 않습니다)
```
name seq qual
testSeqName1 ATTGCCTAATTCG 
testSeqName2 AAGTCGATCGATCG 
```
- 이렇게 행렬이 만들어진 뒤에는 ```awk```와 똑같이 작동하게 되는 겁니다. 몇 번째 컬럼이냐를 다루는 대신, 각 포맷에 해당하는 정보에 맞춰서 컬럼이 지정된다는 게 다를 뿐이죠. 더 많은 정보는 [공식 홈페이지](https://github.com/lh3/bioawk)나 다른 분들이 [만들어둔 매뉴얼](https://bioinformaticsworkbook.org/Appendix/Unix/bioawk-basics.html#gsc.tab=0)을 읽어보시면 확인 가능합니다.
- 실제로 활용 예는








